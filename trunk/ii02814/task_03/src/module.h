/**
 * @file module.h
 * @brief Заголовочный файл с функциями ПИД-регулятора и модели объекта
 * @author Козловский Е.Ю. ИИ-28
 * @date 2025
 */

#ifndef MODULE_H
#define MODULE_H

#include <array>

/**
 * @brief Структура для хранения параметров управления ПИД-регулятором
 */
struct ControlParams {
    double q0;      ///< Коэффициент q0 ПИД-регулятора
    double q1;      ///< Коэффициент q1 ПИД-регулятора
    double q2;      ///< Коэффициент q2 ПИД-регулятора
    double e_k;     ///< Текущая ошибка регулирования
    double e_prev;  ///< Ошибка на предыдущем шаге
    double e_prev2; ///< Ошибка на предпредыдущем шаге
    double u_prev;  ///< Управление на предыдущем шаге
};

/**
 * @brief Структура для хранения параметров нелинейной модели
 */
struct ModelParams {
    double a;       ///< Коэффициент a нелинейной модели
    double b;       ///< Коэффициент b нелинейной модели
    double c;       ///< Коэффициент c нелинейной модели
    double d;       ///< Коэффициент d нелинейной модели
    double y1;      ///< Выход объекта на предыдущем шаге (y(k-1))
    double y0;      ///< Выход объекта на предпредыдущем шаге (y(k-2))
    double u1;      ///< Управление на предыдущем шаге (u(k-1))
    double u0;      ///< Управление на предпредыдущем шаге (u(k-2))
};

/**
 * @brief Структура для хранения переменных состояния системы
 */
struct StateVariables {
    std::array<double, 3> y;    ///< Массив температур: y(k), y(k-1), y(k-2)
    std::array<double, 2> u;    ///< Массив управлений: u(k), u(k-1)
    double e_prev;              ///< Предыдущая ошибка регулирования
    double e_prev2;             ///< Предпредыдущая ошибка регулирования  
    double u_prev;              ///< Предыдущее управляющее воздействие
    double e_k;                 ///< Текущая ошибка регулирования
};

/**
 * @brief Расчет коэффициентов ПИД-регулятора для дискретной формы
 * @param K Коэффициент усиления объекта
 * @param T Постоянная времени объекта
 * @param Td Постоянная времени дифференцирования
 * @param T0 Время дискретизации
 * @param[out] q0 Выходной параметр: коэффициент q0
 * @param[out] q1 Выходной параметр: коэффициент q1  
 * @param[out] q2 Выходной параметр: коэффициент q2
 * 
 * Функция вычисляет коэффициенты ПИД-регулятора в дискретной форме
 * на основе параметров объекта и времени дискретизации.
 */
void calculatePidCoefficients(double K, double T, double Td, double T0, 
                             double& q0, double& q1, double& q2);

/**
 * @brief Расчет управляющего воздействия ПИД-регулятором
 * @param params Структура с параметрами управления
 * @return Рассчитанное управляющее воздействие
 * 
 * Функция реализует алгоритм ПИД-регулятора в дискретной форме:
 * u(k) = u(k-1) + q0*e(k) + q1*e(k-1) + q2*e(k-2)
 */
double calculateControl(const ControlParams& params);

/**
 * @brief Применение ограничений к управляющему воздействию
 * @param u Рассчитанное управляющее воздействие
 * @return Управление с примененными ограничениями
 * 
 * Функция ограничивает управляющее воздействие в диапазоне [0, 100]
 * для предотвращения насыщения исполнительных механизмов.
 */
double applyControlLimits(double u);

/**
 * @brief Расчет нелинейной модели объекта управления
 * @param params Структура с параметрами модели
 * @return Текущее значение выхода объекта
 * 
 * Функция реализует нелинейную модель объекта вида:
 * y(k) = a*y(k-1) - b*y(k-2)^2 + c*u(k-1) + d*sin(u(k-2))
 */
double calculateNonlinearModel(const ModelParams& params);

/**
 * @brief Защита от отрицательной температуры
 * @param temperature Рассчитанная температура
 * @return Скорректированная температура
 * 
 * Функция обеспечивает защиту от физически некорректных 
 * отрицательных значений температуры, ограничивая снизу нулем.
 */
double applyTemperatureProtection(double temperature);

/**
 * @brief Расчет ошибки регулирования
 * @param setpoint Заданное значение (уставка)
 * @param current_value Текущее значение процесса
 * @return Ошибка регулирования
 * 
 * Функция вычисляет разность между заданным и текущим значением.
 * Для систем, где ошибка вычисляется иначе, требуется модификация.
 */
double calculateError(double setpoint, double current_value);

/**
 * @brief Обновление переменных состояния для следующей итерации
 * @param[in,out] state Структура с переменными состояния
 * 
 * Функция сдвигает массивы и переменные состояния для подготовки
 * к следующему шагу расчета, сохраняя историю значений.
 */
void updateStateVariables(StateVariables& state);

#endif