/**
 * @file PID.h
 * @brief Заголовочный файл класса дискретного PID-регулятора.
 *
 * Данный PID работает в форме приращений:
 * \f[
 *     \Delta u = q_0 e(k) + q_1 e(k-1) + q_2 e(k-2)
 * \f]
 * где коэффициенты q0, q1, q2 вычисляются через параметры K, T, T0, Td.
 */
#ifndef PID_H
#define PID_H

 /**
  * @class PID
  * @brief Класс дискретного PID-регулятора.
  *
  * Поддерживает работу с ошибками текущего шага,
  * предыдущего и предпредыдущего.
  */
class PID {
private:
	double K;   ///< Коэффициент усиления.
	double T;   ///< Время интегрирования.
	double T0;  ///< Период дискретизации.
	double Td;  ///< Время дифференцирования.
	
	double q0;  ///< Дискретный коэффициент q0.
	double q1;  ///< Дискретный коэффициент q1.
	double q2;  ///< Дискретный коэффициент q2.

	double u_prev = 0.0;   ///< Предыдущее значение управляющего воздействия.
	double e_prev_1 = 0.0; ///< Ошибка предыдущего шага.
	double e_prev_2 = 0.0; ///< Ошибка шага k-2.
	bool valid = false;    ///< Флаг корректности состояния.


public:

	/**
	 * @brief Конструктор PID-регулятора.
	 *
	 * @param in_K Коэффициент усиления.
	 * @param in_T Период интегрирования.
	 * @param in_Td Время дифференцирования.
	 * @param in_T0 Период дискретизации.
	 */
	PID(double in_K, double in_T, double in_T0, double in_Td);

	/**
	 * @brief Вычисляет управляющее воздействие по текущей ошибке.
	 *
	 * @param e Ошибка регулирования.
	 * @return Новое значение управляющего сигнала.
	 */
	double u_calc(double e);

	/**
	 * @brief Делает коэффициенты недействительными (для тестов).
	 */
	void invalidate() { valid = false; }

	/**
	 * @brief Деструктор.
	 */
	~PID() = default;
};

#endif // PID_H
